# Руководство как мониторить базу PostgreSQL
1. **pg_stat_activity** - можно наблюдать за происходящими в базе процессами в реальном времени (типа top для psql)
Примеры команд:  
Общий запрос ([описание столбцов в официальной документации](https://postgrespro.ru/docs/postgresql/11/monitoring-stats#PG-STAT-ACTIVITY-VIEW)):  
> select * from pg_stat_activity;

Продолжительность транзакции или запроса:  
>    select  
>    client_addr, usename, datname,  
>    clock_timestamp() - xact_start as xact_age,  
>    clock_timestamp() - query_start as query_age,  
>    state, query, wait_event_type, wait_event  
>  from pg_stat_activity  
>  order by coalesce(xact_start,query_start);  

Поле state определяет текущее статус подключения и может принимать одно из нескольких состояний:  
*active* - это рабочее состояние процесса и означает что процесс выполняет запрос.  
*idle* - это холостой процесс , никакой полезной работы не делается (если количество idle процессов измерятся десятками, то стоит подумать о внедрении pgbouncer).  
*idle in transaction* - это холостой процесс внутри открытой транзакции (приложение открыло транзакцию и ничего в ней не делает). Долгие процессы (больше одного часа) с таким статусом вредны для базы данных и их следует завершать (с помощью pg_terminate_backend()), а причины такого поведения в приложении устранять.  
*idle in transaction (aborted)* - это сломаная транзакция, когда внутри нее один из запросов завершился ошибкой, все последующие запросы будут проигнорированы.  
*fastpath function call* - процесс выполняющий fast-path функцию.  
*disabled* - это состояние-заглушка, оно показывается только если отключен параметр track_activities.  

*wait_event_type* - тип события, которого ждёт обслуживающий процесс, если это имеет место; в противном случае — NULL. Возможные значения:  
*LWLock*: обслуживающий процесс ожидает лёгкую блокировку. Такие блокировки защищают определённые структуры данных в разделяемой памяти. В wait_event будет содержаться имя, отражающее цель получения лёгкой блокировки. (Некоторые блокировки имеют особые имена; другие объединяются в группы блокировок со схожим предназначением.)  
*Lock*: Обслуживающий процесс ожидает тяжёлую блокировку. Тяжёлые блокировки, также называемые блокировками менеджера блокировок или просто блокировками, в основном защищают объекты уровня SQL, такие как таблицы. Однако они также применяются для взаимоисключающего выполнения некоторых внутренних операций, например, для расширения отношений. Тип ожидаемой блокировки показывается в wait_event.  
*BufferPin*: Серверный процесс ожидает доступа к буферу данных, когда никакой другой процесс не обращается к этому буферу. Ожидание закрепления буфера может растягиваться, если другой процесс удерживает открытый курсор, который читал данные из нужного буфера.  
*Activity*: Серверный процесс простаивает. Это состояние наблюдается в системных процессах, ожидающих активности в основном цикле обработки. В wait_event обозначается конкретное место ожидания.  
*Extension*: Серверный процесс ожидает активности в модуле расширения. Эта категория полезна при использовании модулей, она помогает отслеживать нестандартные места ожидания.  
*Client*: Серверный процесс ожидает в сокете некоторую активность пользовательского приложения, и события, ожидаемые сервером, не зависят от его внутренних процессов. В wait_event обозначается конкретное место ожидания.  
*IPC*: Серверный процесс ожидает некоторой активности другого процесса на сервере. В wait_event обозначается конкретное место ожидания.  
*Timeout*: Серверный процесс ожидает истечения определённого времени. В wait_event обозначается конкретное место ожидания.  
*IO*: Серверный процесс ожидает завершения операции ввода/вывода. В wait_event обозначается конкретное место ожидания.  

Фильтрация idle и коротких запросов (менее 10 секунд):  
> select  
>    client_addr, usename, datname,  
>    clock_timestamp() - xact_start as xact_age,  
>    clock_timestamp() - query_start as query_age,  
>    state, query  
>  FROM pg_stat_activity  
>  WHERE (  
> (clock_timestamp() - xact_start) > '00:00:10'::interval OR  
> (clock_timestamp() - query_start) > '00:00:10'::interval AND  
> state <> 'idle'  
> )  
>  ORDER BY coalesce(xact_start,query_start);  

