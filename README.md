# Руководство как мониторить базу PostgreSQL
1. **pg_stat_activity** - можно наблюдать за происходящими в базе процессами в реальном времени (типа top для psql)
Примеры команд:  
Общий запрос ([описание столбцов в официальной документации](https://postgrespro.ru/docs/postgresql/11/monitoring-stats#PG-STAT-ACTIVITY-VIEW)):  
> select * from pg_stat_activity;

Продолжительность транзакции или запроса:  
>    select  
>    client_addr, usename, datname,  
>    clock_timestamp() - xact_start as xact_age,  
>    clock_timestamp() - query_start as query_age,  
>    state, query, wait_event_type, wait_event  
>  from pg_stat_activity  
>  order by coalesce(xact_start,query_start);  

Поле state определяет текущее статус подключения и может принимать одно из нескольких состояний:  
*active* - это рабочее состояние процесса и означает что процесс выполняет запрос.  
*idle* - это холостой процесс , никакой полезной работы не делается (если количество idle процессов измерятся десятками, то стоит подумать о внедрении pgbouncer).  
*idle in transaction* - это холостой процесс внутри открытой транзакции (приложение открыло транзакцию и ничего в ней не делает). Долгие процессы (больше одного часа) с таким статусом вредны для базы данных и их следует завершать (с помощью pg_terminate_backend()), а причины такого поведения в приложении устранять.  
*idle in transaction (aborted)* - это сломаная транзакция, когда внутри нее один из запросов завершился ошибкой, все последующие запросы будут проигнорированы.  
*fastpath function call* - процесс выполняющий fast-path функцию.  
*disabled* - это состояние-заглушка, оно показывается только если отключен параметр track_activities.  

*wait_event_type* - тип события, которого ждёт обслуживающий процесс, если это имеет место; в противном случае — NULL. Возможные значения:  
*LWLock*: обслуживающий процесс ожидает лёгкую блокировку. Такие блокировки защищают определённые структуры данных в разделяемой памяти. В wait_event будет содержаться имя, отражающее цель получения лёгкой блокировки. (Некоторые блокировки имеют особые имена; другие объединяются в группы блокировок со схожим предназначением.)  
*Lock*: Обслуживающий процесс ожидает тяжёлую блокировку. Тяжёлые блокировки, также называемые блокировками менеджера блокировок или просто блокировками, в основном защищают объекты уровня SQL, такие как таблицы. Однако они также применяются для взаимоисключающего выполнения некоторых внутренних операций, например, для расширения отношений. Тип ожидаемой блокировки показывается в wait_event.  
*BufferPin*: Серверный процесс ожидает доступа к буферу данных, когда никакой другой процесс не обращается к этому буферу. Ожидание закрепления буфера может растягиваться, если другой процесс удерживает открытый курсор, который читал данные из нужного буфера.  
*Activity*: Серверный процесс простаивает. Это состояние наблюдается в системных процессах, ожидающих активности в основном цикле обработки. В wait_event обозначается конкретное место ожидания.  
*Extension*: Серверный процесс ожидает активности в модуле расширения. Эта категория полезна при использовании модулей, она помогает отслеживать нестандартные места ожидания.  
*Client*: Серверный процесс ожидает в сокете некоторую активность пользовательского приложения, и события, ожидаемые сервером, не зависят от его внутренних процессов. В wait_event обозначается конкретное место ожидания.  
*IPC*: Серверный процесс ожидает некоторой активности другого процесса на сервере. В wait_event обозначается конкретное место ожидания.  
*Timeout*: Серверный процесс ожидает истечения определённого времени. В wait_event обозначается конкретное место ожидания.  
*IO*: Серверный процесс ожидает завершения операции ввода/вывода. В wait_event обозначается конкретное место ожидания.  

Фильтрация idle и коротких запросов (менее 10 секунд):  
> select  
>    client_addr, usename, datname,  
>    clock_timestamp() - xact_start as xact_age,  
>    clock_timestamp() - query_start as query_age,  
>    state, query  
>  FROM pg_stat_activity  
>  WHERE (  
> (clock_timestamp() - xact_start) > '00:00:10'::interval OR  
> (clock_timestamp() - query_start) > '00:00:10'::interval AND  
> state <> 'idle'  
> )  
>  ORDER BY coalesce(xact_start,query_start);  

2. **pg_locks** - даёт доступ к информации о блокировках, удерживаемых активными процессами  
В момент возникновения долгой блокировки мы можем выполнить запрос к представлению pg_locks, посмотреть на блокируемые и блокирующие транзакции (функция pg_blocking_pids) и расшифровывать их при помощи pg_stat_activity.  
Смотрим процессы которые ждут блокировки (другой процесс удерживает или ожидает блокировку того же объекта в конфликтующем режиме). Ожидающий процесс будет приостановлен до освобождения другой блокировки (или выявления ситуации взаимоблокировки). Один процесс в один момент времени может ожидать получения максимум одной блокировки.
> SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa  
>    ON pl.pid = psa.pid WHERE granted='f';  

или посмотреть длительные блокировки:  
> SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa  
>    ON pl.pid = psa.pid WHERE (  
> (clock_timestamp() - xact_start) > '00:00:10'::interval OR  
> (clock_timestamp() - query_start) > '00:00:10'::interval AND  
> granted='f'  
> );  

Смотрим блокировки и какие процессы ждут их (whait for):  
> SELECT locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for  
> FROM pg_locks;  

Можно включить параметр log_lock_waits = on в файле конфигурации. В этом случае в журнал сообщений сервера (логи) будет попадать информация, если транзакция ждала дольше, чем deadlock_timeout (по умолчанию 1 секунда) (несмотря на то, что используется параметр для взаимоблокировок, речь идет об обычных ожиданиях).

Хорошая статья про блокировки на [хабре](https://habr.com/ru/company/postgrespro/blog/462877/)

3. **pg_stat_statements** дает возможность отслеживать статистику выполнения сервером всех операторов SQL  
Для включения добавляем строку в postgresql.conf:  
> shared_preload_libraries = ‘pg_stat_statements’  

Создаем представление, необходимое для доступа к данным:  
> CREATE EXTENSION pg_stat_statements;  

20 запросов, занимающих много времени:
> SELECT substring(query, 1, 100) AS short_query,  
>              round(total_time::numeric, 2) AS total_time,  
>              calls, min_time, max_time,
>              round(mean_time::numeric, 2) AS mean  
> FROM  pg_stat_statements 
> ORDER BY mean DESC  
> LIMIT 20;  

